From: =?utf-8?q?Zbigniew_J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Mon, 14 Jul 2014 19:24:46 -0400
Subject: shell-completion: restore completion for -p

It was broken since systemd was moved out of /bin.

For zsh it was never there.

(cherry picked from commit c0a67aef31bb9716617ffe150ca8be19c5df203e)
---
 Makefile.am                        |  19 +-
 shell-completion/bash/.gitignore   |   1 +
 shell-completion/bash/systemctl    | 226 -----------------------
 shell-completion/bash/systemctl.in | 226 +++++++++++++++++++++++
 shell-completion/zsh/.gitignore    |   1 +
 shell-completion/zsh/_systemctl    | 341 -----------------------------------
 shell-completion/zsh/_systemctl.in | 354 +++++++++++++++++++++++++++++++++++++
 7 files changed, 599 insertions(+), 569 deletions(-)
 create mode 100644 shell-completion/bash/.gitignore
 delete mode 100644 shell-completion/bash/systemctl
 create mode 100644 shell-completion/bash/systemctl.in
 create mode 100644 shell-completion/zsh/.gitignore
 delete mode 100644 shell-completion/zsh/_systemctl
 create mode 100644 shell-completion/zsh/_systemctl.in

diff --git a/Makefile.am b/Makefile.am
index 025461b..9847ff5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -383,7 +383,6 @@ systemgenerator_PROGRAMS = \
 dist_bashcompletion_DATA = \
 	shell-completion/bash/busctl \
 	shell-completion/bash/journalctl \
-	shell-completion/bash/systemctl \
 	shell-completion/bash/systemd-analyze \
 	shell-completion/bash/systemd-cat \
 	shell-completion/bash/systemd-cgls \
@@ -395,8 +394,10 @@ dist_bashcompletion_DATA = \
 	shell-completion/bash/udevadm \
 	shell-completion/bash/kernel-install
 
+nodist_bashcompletion_DATA = \
+	shell-completion/bash/systemctl
+
 dist_zshcompletion_DATA = \
-	shell-completion/zsh/_systemctl \
 	shell-completion/zsh/_journalctl \
 	shell-completion/zsh/_udevadm \
 	shell-completion/zsh/_kernel-install \
@@ -407,6 +408,17 @@ dist_zshcompletion_DATA = \
 	shell-completion/zsh/_systemd-delta \
 	shell-completion/zsh/_systemd
 
+nodist_zshcompletion_DATA = \
+	shell-completion/zsh/_systemctl
+
+EXTRA_DIST += \
+	shell-completion/bash/systemctl.in \
+	shell-completion/zsh/_systemctl.in
+
+CLEANFILES += \
+	$(nodist_bashcompletion_DATA) \
+	$(nodist_zshcompletion_DATA)
+
 dist_sysctl_DATA = \
 	sysctl.d/50-default.conf
 
@@ -5196,6 +5208,9 @@ src/core/macros.%: src/core/macros.%.in
 src/%.policy.in: src/%.policy.in.in
 	$(SED_PROCESS)
 
+shell-completion/%: shell-completion/%.in
+	$(SED_PROCESS)
+
 %.rules: %.rules.in
 	$(SED_PROCESS)
 
diff --git a/shell-completion/bash/.gitignore b/shell-completion/bash/.gitignore
new file mode 100644
index 0000000..016e09d
--- /dev/null
+++ b/shell-completion/bash/.gitignore
@@ -0,0 +1 @@
+/systemctl
diff --git a/shell-completion/bash/systemctl b/shell-completion/bash/systemctl
deleted file mode 100644
index e1c8420..0000000
--- a/shell-completion/bash/systemctl
+++ /dev/null
@@ -1,226 +0,0 @@
-# systemctl(1) completion                                 -*- shell-script -*-
-#
-# This file is part of systemd.
-#
-# Copyright 2010 Ran Benita
-#
-# systemd is free software; you can redistribute it and/or modify it
-# under the terms of the GNU Lesser General Public License as published by
-# the Free Software Foundation; either version 2.1 of the License, or
-# (at your option) any later version.
-#
-# systemd is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public License
-# along with systemd; If not, see <http://www.gnu.org/licenses/>.
-
-__systemctl() {
-        local mode=$1; shift 1
-        systemctl $mode --full --no-legend "$@"
-}
-
-__systemd_properties() {
-        local mode=$1
-        { __systemctl -a $mode show;
-         systemd --dump-configuration-items; } |
-        while IFS='=' read -r key value; do
-            [[ $value ]] && echo "$key"
-        done
-}
-
-__contains_word () {
-        local w word=$1; shift
-        for w in "$@"; do
-                [[ $w = "$word" ]] && return
-        done
-}
-
-__filter_units_by_property () {
-        local mode=$1 property=$2 value=$3 ; shift 3
-        local units=("$@")
-        local props
-        IFS=$'\n' read -rd '' -a props < \
-            <(__systemctl $mode show --property "$property" -- "${units[@]}")
-        for ((i=0; $i < ${#units[*]}; i++)); do
-                if [[ "${props[i]}" = "$property=$value" ]]; then
-                        echo " ${units[i]}"
-                fi
-        done
-}
-
-__get_all_units      () { __systemctl $1 list-units --all \
-        | { while read -r a b; do echo " $a"; done; }; }
-__get_active_units   () { __systemctl $1 list-units       \
-        | { while read -r a b; do echo " $a"; done; }; }
-__get_startable_units () { __systemctl $1 list-units --all -t service,timer,socket,mount,automount,path,snapshot,swap \
-        | { while read -r a b c d; do [[ $c == "inactive" || $c == "failed" ]] && echo " $a"; done; }; }
-__get_failed_units   () { __systemctl $1 list-units       \
-        | { while read -r a b c d; do [[ $c == "failed"   ]] && echo " $a"; done; }; }
-__get_enabled_units  () { __systemctl $1 list-unit-files  \
-        | { while read -r a b c  ; do [[ $b == "enabled"  ]] && echo " $a"; done; }; }
-__get_disabled_units () { __systemctl $1 list-unit-files  \
-        | { while read -r a b c  ; do [[ $b == "disabled" ]] && echo " $a"; done; }; }
-__get_masked_units   () { __systemctl $1 list-unit-files  \
-        | { while read -r a b c  ; do [[ $b == "masked"   ]] && echo " $a"; done; }; }
-
-_systemctl () {
-        local cur=${COMP_WORDS[COMP_CWORD]} prev=${COMP_WORDS[COMP_CWORD-1]}
-        local i verb comps mode
-
-        local -A OPTS=(
-               [STANDALONE]='--all -a --reverse --after --before --defaults --fail --ignore-dependencies --failed --force -f --full -l --global
-                             --help -h --no-ask-password --no-block --no-legend --no-pager --no-reload --no-wall
-                             --quiet -q --privileged -P --system --user --version --runtime --recursive -r'
-                      [ARG]='--host -H --kill-who --property -p --signal -s --type -t --state --root'
-        )
-
-        if __contains_word "--user" ${COMP_WORDS[*]}; then
-            mode=--user
-        else
-            mode=--system
-        fi
-
-        if __contains_word "$prev" ${OPTS[ARG]}; then
-                case $prev in
-                        --signal|-s)
-                                comps=$(compgen -A signal)
-                        ;;
-                        --type|-t)
-                                comps='automount device mount path service snapshot socket swap target timer'
-                        ;;
-                        --state)
-                                comps='loaded not-found stub
-                                       active inactive
-                                       dead elapsed exited listening mounted plugged running waiting'
-                        ;;
-                        --kill-who)
-                                comps='all control main'
-                        ;;
-                        --root)
-                                comps=$(compgen -A directory -- "$cur" )
-                                compopt -o filenames
-                        ;;
-                        --host|-H)
-                                comps=$(compgen -A hostname)
-                        ;;
-                        --property|-p)
-                                comps=$(__systemd_properties $mode)
-                        ;;
-                esac
-                COMPREPLY=( $(compgen -W '$comps' -- "$cur") )
-                return 0
-        fi
-
-        if [[ "$cur" = -* ]]; then
-                COMPREPLY=( $(compgen -W '${OPTS[*]}' -- "$cur") )
-                return 0
-        fi
-
-        local -A VERBS=(
-                [ALL_UNITS]='is-active is-failed is-enabled status show cat mask preset help list-dependencies'
-            [ENABLED_UNITS]='disable'
-           [DISABLED_UNITS]='enable'
-        [REENABLABLE_UNITS]='reenable'
-             [FAILED_UNITS]='reset-failed'
-          [STARTABLE_UNITS]='start'
-          [STOPPABLE_UNITS]='stop condstop kill try-restart condrestart'
-         [ISOLATABLE_UNITS]='isolate'
-         [RELOADABLE_UNITS]='reload condreload reload-or-try-restart force-reload'
-        [RESTARTABLE_UNITS]='restart reload-or-restart'
-             [MASKED_UNITS]='unmask'
-                     [JOBS]='cancel'
-                [SNAPSHOTS]='delete'
-                     [ENVS]='set-environment unset-environment'
-               [STANDALONE]='daemon-reexec daemon-reload default
-                             emergency exit halt hibernate hybrid-sleep kexec list-jobs
-                             list-sockets list-timers list-units list-unit-files poweroff
-                             reboot rescue show-environment suspend get-default'
-                     [NAME]='snapshot'
-                     [FILE]='link'
-                  [TARGETS]='set-default'
-        )
-
-        for ((i=0; i < COMP_CWORD; i++)); do
-                if __contains_word "${COMP_WORDS[i]}" ${VERBS[*]} &&
-                 ! __contains_word "${COMP_WORDS[i-1]}" ${OPTS[ARG]}; then
-                        verb=${COMP_WORDS[i]}
-                        break
-                fi
-        done
-
-        if [[ -z $verb ]]; then
-                comps="${VERBS[*]}"
-
-        elif __contains_word "$verb" ${VERBS[ALL_UNITS]}; then
-                comps=$( __get_all_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[ENABLED_UNITS]}; then
-                comps=$( __get_enabled_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[DISABLED_UNITS]}; then
-                comps=$( __get_disabled_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[REENABLABLE_UNITS]}; then
-                comps=$( __get_disabled_units $mode;
-                         __get_enabled_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[STARTABLE_UNITS]}; then
-                comps=$( __filter_units_by_property $mode CanStart yes \
-                      $( __get_startable_units $mode))
-
-        elif __contains_word "$verb" ${VERBS[RESTARTABLE_UNITS]}; then
-                comps=$( __filter_units_by_property $mode CanStart yes \
-                      $( __get_all_units $mode \
-                        | while read -r line; do \
-                                [[ "$line" =~ \.(device|snapshot|socket|timer)$ ]] || echo " $line"; \
-                        done ))
-
-        elif __contains_word "$verb" ${VERBS[STOPPABLE_UNITS]}; then
-                comps=$( __filter_units_by_property $mode CanStop yes \
-                      $( __get_active_units $mode ) )
-
-        elif __contains_word "$verb" ${VERBS[RELOADABLE_UNITS]}; then
-                comps=$( __filter_units_by_property $mode CanReload yes \
-                      $( __get_active_units $mode ) )
-
-        elif __contains_word "$verb" ${VERBS[ISOLATABLE_UNITS]}; then
-                comps=$( __filter_units_by_property $mode AllowIsolate yes \
-                      $( __get_all_units $mode ) )
-
-        elif __contains_word "$verb" ${VERBS[FAILED_UNITS]}; then
-                comps=$( __get_failed_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[MASKED_UNITS]}; then
-                comps=$( __get_masked_units $mode )
-
-        elif __contains_word "$verb" ${VERBS[STANDALONE]} ${VERBS[NAME]}; then
-                comps=''
-
-        elif __contains_word "$verb" ${VERBS[JOBS]}; then
-                comps=$( __systemctl $mode list-jobs | { while read -r a b; do echo " $a"; done; } )
-
-        elif __contains_word "$verb" ${VERBS[SNAPSHOTS]}; then
-                comps=$( __systemctl $mode list-units --type snapshot --full --all \
-                        | { while read -r a b; do echo " $a"; done; } )
-
-        elif __contains_word "$verb" ${VERBS[ENVS]}; then
-                comps=$( __systemctl $mode show-environment \
-                    | while read -r line; do echo " ${line%%=*}=";done )
-                compopt -o nospace
-
-        elif __contains_word "$verb" ${VERBS[FILE]}; then
-                comps=$( compgen -A file -- "$cur" )
-                compopt -o filenames
-        elif __contains_word "$verb" ${VERBS[TARGETS]}; then
-                comps=$( __systemctl $mode list-unit-files --type target --full --all \
-                        | { while read -r a b; do echo " $a"; done; } )
-        fi
-
-        COMPREPLY=( $(compgen -W '$comps' -- "$cur") )
-        return 0
-}
-
-complete -F _systemctl systemctl
diff --git a/shell-completion/bash/systemctl.in b/shell-completion/bash/systemctl.in
new file mode 100644
index 0000000..4beec4e
--- /dev/null
+++ b/shell-completion/bash/systemctl.in
@@ -0,0 +1,226 @@
+# systemctl(1) completion                                 -*- shell-script -*-
+#
+# This file is part of systemd.
+#
+# Copyright 2010 Ran Benita
+#
+# systemd is free software; you can redistribute it and/or modify it
+# under the terms of the GNU Lesser General Public License as published by
+# the Free Software Foundation; either version 2.1 of the License, or
+# (at your option) any later version.
+#
+# systemd is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public License
+# along with systemd; If not, see <http://www.gnu.org/licenses/>.
+
+__systemctl() {
+        local mode=$1; shift 1
+        systemctl $mode --full --no-legend "$@"
+}
+
+__systemd_properties() {
+        local mode=$1
+        { __systemctl $mode show --all;
+         @rootlibexecdir@/systemd --dump-configuration-items; } |
+        while IFS='=' read -r key value; do
+            [[ $value ]] && echo "$key"
+        done
+}
+
+__contains_word () {
+        local w word=$1; shift
+        for w in "$@"; do
+                [[ $w = "$word" ]] && return
+        done
+}
+
+__filter_units_by_property () {
+        local mode=$1 property=$2 value=$3 ; shift 3
+        local units=("$@")
+        local props
+        IFS=$'\n' read -rd '' -a props < \
+            <(__systemctl $mode show --property "$property" -- "${units[@]}")
+        for ((i=0; $i < ${#units[*]}; i++)); do
+                if [[ "${props[i]}" = "$property=$value" ]]; then
+                        echo " ${units[i]}"
+                fi
+        done
+}
+
+__get_all_units      () { __systemctl $1 list-units --all \
+        | { while read -r a b; do echo " $a"; done; }; }
+__get_active_units   () { __systemctl $1 list-units       \
+        | { while read -r a b; do echo " $a"; done; }; }
+__get_startable_units () { __systemctl $1 list-units --all -t service,timer,socket,mount,automount,path,snapshot,swap \
+        | { while read -r a b c d; do [[ $c == "inactive" || $c == "failed" ]] && echo " $a"; done; }; }
+__get_failed_units   () { __systemctl $1 list-units       \
+        | { while read -r a b c d; do [[ $c == "failed"   ]] && echo " $a"; done; }; }
+__get_enabled_units  () { __systemctl $1 list-unit-files  \
+        | { while read -r a b c  ; do [[ $b == "enabled"  ]] && echo " $a"; done; }; }
+__get_disabled_units () { __systemctl $1 list-unit-files  \
+        | { while read -r a b c  ; do [[ $b == "disabled" ]] && echo " $a"; done; }; }
+__get_masked_units   () { __systemctl $1 list-unit-files  \
+        | { while read -r a b c  ; do [[ $b == "masked"   ]] && echo " $a"; done; }; }
+
+_systemctl () {
+        local cur=${COMP_WORDS[COMP_CWORD]} prev=${COMP_WORDS[COMP_CWORD-1]}
+        local i verb comps mode
+
+        local -A OPTS=(
+               [STANDALONE]='--all -a --reverse --after --before --defaults --fail --ignore-dependencies --failed --force -f --full -l --global
+                             --help -h --no-ask-password --no-block --no-legend --no-pager --no-reload --no-wall
+                             --quiet -q --privileged -P --system --user --version --runtime --recursive -r'
+                      [ARG]='--host -H --kill-who --property -p --signal -s --type -t --state --root'
+        )
+
+        if __contains_word "--user" ${COMP_WORDS[*]}; then
+            mode=--user
+        else
+            mode=--system
+        fi
+
+        if __contains_word "$prev" ${OPTS[ARG]}; then
+                case $prev in
+                        --signal|-s)
+                                comps=$(compgen -A signal)
+                        ;;
+                        --type|-t)
+                                comps='automount device mount path service snapshot socket swap target timer'
+                        ;;
+                        --state)
+                                comps='loaded not-found stub
+                                       active inactive
+                                       dead elapsed exited listening mounted plugged running waiting'
+                        ;;
+                        --kill-who)
+                                comps='all control main'
+                        ;;
+                        --root)
+                                comps=$(compgen -A directory -- "$cur" )
+                                compopt -o filenames
+                        ;;
+                        --host|-H)
+                                comps=$(compgen -A hostname)
+                        ;;
+                        --property|-p)
+                                comps=$(__systemd_properties $mode)
+                        ;;
+                esac
+                COMPREPLY=( $(compgen -W '$comps' -- "$cur") )
+                return 0
+        fi
+
+        if [[ "$cur" = -* ]]; then
+                COMPREPLY=( $(compgen -W '${OPTS[*]}' -- "$cur") )
+                return 0
+        fi
+
+        local -A VERBS=(
+                [ALL_UNITS]='is-active is-failed is-enabled status show cat mask preset help list-dependencies'
+            [ENABLED_UNITS]='disable'
+           [DISABLED_UNITS]='enable'
+        [REENABLABLE_UNITS]='reenable'
+             [FAILED_UNITS]='reset-failed'
+          [STARTABLE_UNITS]='start'
+          [STOPPABLE_UNITS]='stop condstop kill try-restart condrestart'
+         [ISOLATABLE_UNITS]='isolate'
+         [RELOADABLE_UNITS]='reload condreload reload-or-try-restart force-reload'
+        [RESTARTABLE_UNITS]='restart reload-or-restart'
+             [MASKED_UNITS]='unmask'
+                     [JOBS]='cancel'
+                [SNAPSHOTS]='delete'
+                     [ENVS]='set-environment unset-environment'
+               [STANDALONE]='daemon-reexec daemon-reload default
+                             emergency exit halt hibernate hybrid-sleep kexec list-jobs
+                             list-sockets list-timers list-units list-unit-files poweroff
+                             reboot rescue show-environment suspend get-default'
+                     [NAME]='snapshot'
+                     [FILE]='link'
+                  [TARGETS]='set-default'
+        )
+
+        for ((i=0; i < COMP_CWORD; i++)); do
+                if __contains_word "${COMP_WORDS[i]}" ${VERBS[*]} &&
+                 ! __contains_word "${COMP_WORDS[i-1]}" ${OPTS[ARG]}; then
+                        verb=${COMP_WORDS[i]}
+                        break
+                fi
+        done
+
+        if [[ -z $verb ]]; then
+                comps="${VERBS[*]}"
+
+        elif __contains_word "$verb" ${VERBS[ALL_UNITS]}; then
+                comps=$( __get_all_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[ENABLED_UNITS]}; then
+                comps=$( __get_enabled_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[DISABLED_UNITS]}; then
+                comps=$( __get_disabled_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[REENABLABLE_UNITS]}; then
+                comps=$( __get_disabled_units $mode;
+                         __get_enabled_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[STARTABLE_UNITS]}; then
+                comps=$( __filter_units_by_property $mode CanStart yes \
+                      $( __get_startable_units $mode))
+
+        elif __contains_word "$verb" ${VERBS[RESTARTABLE_UNITS]}; then
+                comps=$( __filter_units_by_property $mode CanStart yes \
+                      $( __get_all_units $mode \
+                        | while read -r line; do \
+                                [[ "$line" =~ \.(device|snapshot|socket|timer)$ ]] || echo " $line"; \
+                        done ))
+
+        elif __contains_word "$verb" ${VERBS[STOPPABLE_UNITS]}; then
+                comps=$( __filter_units_by_property $mode CanStop yes \
+                      $( __get_active_units $mode ) )
+
+        elif __contains_word "$verb" ${VERBS[RELOADABLE_UNITS]}; then
+                comps=$( __filter_units_by_property $mode CanReload yes \
+                      $( __get_active_units $mode ) )
+
+        elif __contains_word "$verb" ${VERBS[ISOLATABLE_UNITS]}; then
+                comps=$( __filter_units_by_property $mode AllowIsolate yes \
+                      $( __get_all_units $mode ) )
+
+        elif __contains_word "$verb" ${VERBS[FAILED_UNITS]}; then
+                comps=$( __get_failed_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[MASKED_UNITS]}; then
+                comps=$( __get_masked_units $mode )
+
+        elif __contains_word "$verb" ${VERBS[STANDALONE]} ${VERBS[NAME]}; then
+                comps=''
+
+        elif __contains_word "$verb" ${VERBS[JOBS]}; then
+                comps=$( __systemctl $mode list-jobs | { while read -r a b; do echo " $a"; done; } )
+
+        elif __contains_word "$verb" ${VERBS[SNAPSHOTS]}; then
+                comps=$( __systemctl $mode list-units --type snapshot --full --all \
+                        | { while read -r a b; do echo " $a"; done; } )
+
+        elif __contains_word "$verb" ${VERBS[ENVS]}; then
+                comps=$( __systemctl $mode show-environment \
+                    | while read -r line; do echo " ${line%%=*}=";done )
+                compopt -o nospace
+
+        elif __contains_word "$verb" ${VERBS[FILE]}; then
+                comps=$( compgen -A file -- "$cur" )
+                compopt -o filenames
+        elif __contains_word "$verb" ${VERBS[TARGETS]}; then
+                comps=$( __systemctl $mode list-unit-files --type target --full --all \
+                        | { while read -r a b; do echo " $a"; done; } )
+        fi
+
+        COMPREPLY=( $(compgen -W '$comps' -- "$cur") )
+        return 0
+}
+
+complete -F _systemctl systemctl
diff --git a/shell-completion/zsh/.gitignore b/shell-completion/zsh/.gitignore
new file mode 100644
index 0000000..75f13ad
--- /dev/null
+++ b/shell-completion/zsh/.gitignore
@@ -0,0 +1 @@
+/_systemctl
diff --git a/shell-completion/zsh/_systemctl b/shell-completion/zsh/_systemctl
deleted file mode 100644
index b6cf664..0000000
--- a/shell-completion/zsh/_systemctl
+++ /dev/null
@@ -1,341 +0,0 @@
-#compdef systemctl
-
-(( $+functions[_systemctl_command] )) || _systemctl_command()
-{
-  local -a _systemctl_cmds
-  _systemctl_cmds=(
-    "list-sockets:List sockets"
-    "list-timers:List timers"
-    "list-units:List units"
-    "start:Start (activate) one or more units"
-    "stop:Stop (deactivate) one or more units"
-    "reload:Reload one or more units"
-    "restart:Start or restart one or more units"
-    "condrestart:Restart one or more units if active"
-    "try-restart:Restart one or more units if active"
-    "reload-or-restart:Reload one or more units if possible, otherwise start or restart"
-    "force-reload:Reload one or more units if possible, otherwise restart if active"
-    "hibernate:Hibernate the system"
-    "hybrid-sleep:Hibernate and suspend the system"
-    "reload-or-try-restart:Reload one or more units if possible, otherwise restart if active"
-    "isolate:Start one unit and stop all others"
-    "kill:Send signal to processes of a unit"
-    "is-active:Check whether units are active"
-    "is-failed:Check whether units are failed"
-    "status:Show runtime status of one or more units"
-    "show:Show properties of one or more units/jobs or the manager"
-    "cat:Show the source unit files and drop-ins"
-    "reset-failed:Reset failed state for all, one, or more units"
-    "list-unit-files:List installed unit files"
-    "enable:Enable one or more unit files"
-    "disable:Disable one or more unit files"
-    "reenable:Reenable one or more unit files"
-    "preset:Enable/disable one or more unit files based on preset configuration"
-    "help:Show documentation for specified units"
-    "list-dependencies:Show unit dependency tree"
-    "mask:Mask one or more units"
-    "unmask:Unmask one or more units"
-    "link:Link one or more units files into the search path"
-    "is-enabled:Check whether unit files are enabled"
-    "list-jobs:List jobs"
-    "cancel:Cancel all, one, or more jobs"
-    "snapshot:Create a snapshot"
-    "delete:Remove one or more snapshots"
-    "show-environment:Dump environment"
-    "set-environment:Set one or more environment variables"
-    "unset-environment:Unset one or more environment variables"
-    "daemon-reload:Reload systemd manager configuration"
-    "daemon-reexec:Reexecute systemd manager"
-    "default:Enter system default mode"
-    "rescue:Enter system rescue mode"
-    "emergency:Enter system emergency mode"
-    "halt:Shut down and halt the system"
-    "suspend:Suspend the system"
-    "poweroff:Shut down and power-off the system"
-    "reboot:Shut down and reboot the system"
-    "kexec:Shut down and reboot the system with kexec"
-    "exit:Ask for user instance termination"
-  )
-
-  if (( CURRENT == 1 )); then
-    _describe -t commands 'systemctl command' _systemctl_cmds || compadd "$@"
-  else
-    local curcontext="$curcontext"
-
-    cmd="${${_systemctl_cmds[(r)$words[1]:*]%%:*}}"
-    # Deal with any aliases
-    case $cmd in
-      condrestart) cmd="try-restart";;
-      force-reload) cmd="reload-or-try-restart";;
-    esac
-
-    if (( $#cmd )); then
-      curcontext="${curcontext%:*:*}:systemctl-${cmd}:"
-
-      local update_policy
-      zstyle -s ":completion:${curcontext}:" cache-policy update_policy
-      if [[ -z "$update_policy" ]]; then
-        zstyle ":completion:${curcontext}:" cache-policy _systemctl_caching_policy
-      fi
-
-      _call_function ret _systemctl_$cmd || _message 'no more arguments'
-    else
-      _message "unknown systemctl command: $words[1]"
-    fi
-    return ret
-  fi
-}
-
-__systemctl()
-{
-  local -a _modes
-  _modes=("--user" "--system")
-  systemctl ${words:*_modes} --full --no-legend --no-pager "$@"
-}
-
-
-# Fills the unit list
-_systemctl_all_units()
-{
-  if ( [[ ${+_sys_all_units} -eq 0 ]] || _cache_invalid SYS_ALL_UNITS ) &&
-    ! _retrieve_cache SYS_ALL_UNITS;
-  then
-    _sys_all_units=( $(__systemctl list-units --all | { while read a b; do echo " $a"; done; }) )
-    _store_cache SYS_ALL_UNITS _sys_all_units
-  fi
-}
-
-# Fills the unit list including all file units
-_systemctl_really_all_units()
-{
-  local -a all_unit_files;
-  local -a really_all_units;
-  if ( [[ ${+_sys_really_all_units} -eq 0 ]] || _cache_invalid SYS_REALLY_ALL_UNITS ) &&
-    ! _retrieve_cache SYS_REALLY_ALL_UNITS;
-  then
-    all_unit_files=( $(__systemctl list-unit-files | { while read a b; do echo " $a"; done; }) )
-    _systemctl_all_units
-    really_all_units=($_sys_all_units $all_unit_files)
-    _sys_really_all_units=(${(u)really_all_units})
-    _store_cache SYS_REALLY_ALL_UNITS _sys_really_all_units
-  fi
-}
-
-_filter_units_by_property() {
-  local property=$1 value=$2 ; shift ; shift
-  local -a units ; units=($*)
-  local prop unit
-  for ((i=1; $i <= ${#units[*]}; i++)); do
-    # FIXME: "Failed to issue method call: Unknown unit" errors are ignored for
-    # now (related to DBUS_ERROR_UNKNOWN_OBJECT). in the future, we need to
-    # revert to calling 'systemctl show' once for all units, which is way
-    # faster
-    unit=${units[i]}
-    prop=${(f)"$(_call_program units "$service show --no-pager --property="$property" ${unit} 2>/dev/null")"}
-    if [[ "${prop}" = "$property=$value" ]]; then
-      echo " ${unit}"
-    fi
-  done
-}
-
-_systemctl_active_units()  {_sys_active_units=(  $(__systemctl list-units          | { while read a b; do echo " $a"; done; }) )}
-_systemctl_inactive_units(){_sys_inactive_units=($(__systemctl list-units --all    | { while read a b c d; do [[ $c == "inactive" || $c == "failed" ]] && echo " $a"; done; }) )}
-_systemctl_failed_units()  {_sys_failed_units=(  $(__systemctl list-units --failed | { while read a b; do echo " $a"; done; }) )}
-_systemctl_enabled_units() {_sys_enabled_units=( $(__systemctl list-unit-files     | { while read a b; do [[ $b == "enabled" ]] && echo " $a"; done; }) )}
-_systemctl_disabled_units(){_sys_disabled_units=($(__systemctl list-unit-files     | { while read a b; do [[ $b == "disabled" ]] && echo " $a"; done; }) )}
-_systemctl_masked_units()  {_sys_masked_units=(  $(__systemctl list-unit-files     | { while read a b; do [[ $b == "masked" ]] && echo " $a"; done; }) )}
-
-# Completion functions for ALL_UNITS
-for fun in is-active is-failed is-enabled status show cat mask preset help list-dependencies ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    _systemctl_really_all_units
-    compadd "$@" -a - _sys_really_all_units
-  }
-done
-
-# Completion functions for ENABLED_UNITS
-for fun in disable reenable ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    _systemctl_enabled_units
-    _systemctl_disabled_units
-    compadd "$@" -a - _sys_enabled_units _sys_disabled_units
-  }
-done
-
-# Completion functions for DISABLED_UNITS
-(( $+functions[_systemctl_enable] )) || _systemctl_enable()
-{
-  _systemctl_disabled_units
-  compadd "$@" -a - _sys_disabled_units
-}
-
-# Completion functions for FAILED_UNITS
-(( $+functions[_systemctl_reset-failed] )) || _systemctl_reset-failed()
-{
-  _systemctl_failed_units
-  compadd "$@" -a - _sys_failed_units || _message "no failed unit found"
-}
-
-# Completion functions for STARTABLE_UNITS
-(( $+functions[_systemctl_start] )) || _systemctl_start()
-{
-  _systemctl_inactive_units
-  compadd "$@" -a - _sys_inactive_units
-}
-
-# Completion functions for STOPPABLE_UNITS
-for fun in stop kill try-restart condrestart ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    _systemctl_active_units
-    compadd "$@" - $( _filter_units_by_property CanStop yes \
-      ${_sys_active_units[*]} )
-  }
-done
-
-# Completion functions for ISOLATABLE_UNITS
-(( $+functions[_systemctl_isolate] )) || _systemctl_isolate()
-{
-  _systemctl_all_units
-  compadd "$@" - $( _filter_units_by_property AllowIsolate yes \
-    ${_sys_all_units[*]} )
-}
-
-# Completion functions for RELOADABLE_UNITS
-for fun in reload reload-or-try-restart force-reload ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    _systemctl_active_units
-    compadd "$@" - $( _filter_units_by_property CanReload yes \
-      ${_sys_active_units[*]} )
-  }
-done
-
-# Completion functions for RESTARTABLE_UNITS
-for fun in restart reload-or-restart ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    _systemctl_all_units
-    compadd "$@" - $( _filter_units_by_property CanStart yes \
-      ${_sys_all_units[*]} | while read line; do \
-      [[ "$line" =~ \.device$ ]] || echo " $line"; \
-      done )
-  }
-done
-
-# Completion functions for MASKED_UNITS
-(( $+functions[_systemctl_unmask] )) || _systemctl_unmask()
-{
-  _systemctl_masked_units
-  compadd "$@" -a - _sys_masked_units || _message "no masked unit found"
-}
-
-# Completion functions for JOBS
-(( $+functions[_systemctl_cancel] )) || _systemctl_cancel()
-{
-  compadd "$@" - $(__systemctl list-jobs \
-    | cut -d' ' -f1  2>/dev/null ) || _message "no job found"
-}
-
-# Completion functions for SNAPSHOTS
-(( $+functions[_systemctl_delete] )) || _systemctl_delete()
-{
-  compadd "$@" - $(__systemctl list-units --type snapshot --all \
-    | cut -d' ' -f1  2>/dev/null ) || _message "no snapshot found"
-}
-
-# Completion functions for ENVS
-for fun in set-environment unset-environment ; do
-  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
-  {
-    local fun=$0 ; fun=${fun##_systemctl_}
-    local suf
-    if [[ "${fun}" = "set-environment" ]]; then
-      suf='-S='
-    fi
-
-    compadd "$@" ${suf} - $(systemctl show-environment \
-      | while read line; do echo " ${line%%\=}";done )
-  }
-done
-
-(( $+functions[_systemctl_link] )) || _systemctl_link() { _files }
-
-# no systemctl completion for:
-#    [STANDALONE]='daemon-reexec daemon-reload default
-#                  emergency exit halt kexec list-jobs list-units
-#                  list-unit-files poweroff reboot rescue show-environment'
-#         [NAME]='snapshot'
-
-_systemctl_caching_policy()
-{
-  local _sysunits
-  local -a oldcache
-
-  # rebuild if cache is more than a day old
-  oldcache=( "$1"(mh+1) )
-  (( $#oldcache )) && return 0
-
-  _sysunits=($(__systemctl --all | cut -d' ' -f1))
-
-  if (( $#_sysunits )); then
-    for unit in $_sysunits; do
-      [[ "$unit" -nt "$1" ]] && return 0
-    done
-  fi
-
-  return 1
-}
-
-_unit_states() {
-    local -a _states
-    _states=(loaded failed active inactive not-found listening running waiting plugged mounted exited dead masked)
-    _values -s , "${_states[@]}"
-}
-
-_unit_types() {
-    local -a _types
-    _types=(automount device mount path service snapshot socket swap target timer)
-    _values -s , "${_types[@]}"
-}
-
-_arguments -s \
-    {-h,--help}'[Show help]' \
-    '--version[Show package version]' \
-    {-t+,--type=}'[List only units of a particular type]:unit type:_unit_types' \
-    '--state=[Display units in the specifyied state]:unit state:_unit_states' \
-    \*{-p+,--property=}'[Show only properties by specific name]:unit property' \
-    {-a,--all}'[Show all units/properties, including dead/empty ones]' \
-    '--reverse[Show reverse dependencies]' \
-    '--after[Show units ordered after]' \
-    '--before[Show units ordered before]' \
-    '--failed[Show only failed units]' \
-    {-l,--full}"[Don't ellipsize unit names on output]" \
-    '--fail[When queueing a new job, fail if conflicting jobs are pending]' \
-    '--show-types[When showing sockets, show socket type]' \
-    '--irreversible[Mark transactions as irreversible]' \
-    '--ignore-dependencies[When queueing a new job, ignore all its dependencies]' \
-    {-i,--ignore-inhibitors}'[When executing a job, ignore jobs dependencies]' \
-    {-q,--quiet}'[Suppress output]' \
-    '--no-block[Do not wait until operation finished]' \
-    '--no-legend[Do not print a legend, i.e. the column headers and the footer with hints]' \
-    '--no-pager[Do not pipe output into a pager]' \
-    '--system[Connect to system manager]' \
-    '--user[Connect to user service manager]' \
-    "--no-wall[Don't send wall message before halt/power-off/reboot]" \
-    '--global[Enable/disable unit files globally]' \
-    "--no-reload[When enabling/disabling unit files, don't reload daemon configuration]" \
-    '--no-ask-password[Do not ask for system passwords]' \
-    '--kill-who=[Who to send signal to]:killwho:(main control all)' \
-    {-s+,--signal=}'[Which signal to send]:signal:_signals' \
-    {-f,--force}'[When enabling unit files, override existing symlinks. When shutting down, execute action immediately]' \
-    '--root=[Enable unit files in the specified root directory]:directory:_directories' \
-    '--runtime[Enable unit files only temporarily until next reboot]' \
-    {-H+,--host=}'[Operate on remote host]:userathost:_sd_hosts_or_user_at_host' \
-    {-P,--privileged}'[Acquire privileges before execution]' \
-    {-n+,--lines=}'[Journal entries to show]:number of entries' \
-    {-o+,--output=}'[Change journal output mode]:modes:_sd_outputmodes' \
-    '--plain[When used with list-dependencies, print output as a list]' \
-    '*::systemctl command:_systemctl_command'
diff --git a/shell-completion/zsh/_systemctl.in b/shell-completion/zsh/_systemctl.in
new file mode 100644
index 0000000..d9b8d1c
--- /dev/null
+++ b/shell-completion/zsh/_systemctl.in
@@ -0,0 +1,354 @@
+#compdef systemctl
+
+(( $+functions[_systemctl_command] )) || _systemctl_command()
+{
+  local -a _systemctl_cmds
+  _systemctl_cmds=(
+    "list-sockets:List sockets"
+    "list-timers:List timers"
+    "list-units:List units"
+    "start:Start (activate) one or more units"
+    "stop:Stop (deactivate) one or more units"
+    "reload:Reload one or more units"
+    "restart:Start or restart one or more units"
+    "condrestart:Restart one or more units if active"
+    "try-restart:Restart one or more units if active"
+    "reload-or-restart:Reload one or more units if possible, otherwise start or restart"
+    "force-reload:Reload one or more units if possible, otherwise restart if active"
+    "hibernate:Hibernate the system"
+    "hybrid-sleep:Hibernate and suspend the system"
+    "reload-or-try-restart:Reload one or more units if possible, otherwise restart if active"
+    "isolate:Start one unit and stop all others"
+    "kill:Send signal to processes of a unit"
+    "is-active:Check whether units are active"
+    "is-failed:Check whether units are failed"
+    "status:Show runtime status of one or more units"
+    "show:Show properties of one or more units/jobs or the manager"
+    "cat:Show the source unit files and drop-ins"
+    "reset-failed:Reset failed state for all, one, or more units"
+    "list-unit-files:List installed unit files"
+    "enable:Enable one or more unit files"
+    "disable:Disable one or more unit files"
+    "reenable:Reenable one or more unit files"
+    "preset:Enable/disable one or more unit files based on preset configuration"
+    "help:Show documentation for specified units"
+    "list-dependencies:Show unit dependency tree"
+    "mask:Mask one or more units"
+    "unmask:Unmask one or more units"
+    "link:Link one or more units files into the search path"
+    "is-enabled:Check whether unit files are enabled"
+    "list-jobs:List jobs"
+    "cancel:Cancel all, one, or more jobs"
+    "snapshot:Create a snapshot"
+    "delete:Remove one or more snapshots"
+    "show-environment:Dump environment"
+    "set-environment:Set one or more environment variables"
+    "unset-environment:Unset one or more environment variables"
+    "daemon-reload:Reload systemd manager configuration"
+    "daemon-reexec:Reexecute systemd manager"
+    "default:Enter system default mode"
+    "rescue:Enter system rescue mode"
+    "emergency:Enter system emergency mode"
+    "halt:Shut down and halt the system"
+    "suspend:Suspend the system"
+    "poweroff:Shut down and power-off the system"
+    "reboot:Shut down and reboot the system"
+    "kexec:Shut down and reboot the system with kexec"
+    "exit:Ask for user instance termination"
+  )
+
+  if (( CURRENT == 1 )); then
+    _describe -t commands 'systemctl command' _systemctl_cmds || compadd "$@"
+  else
+    local curcontext="$curcontext"
+
+    cmd="${${_systemctl_cmds[(r)$words[1]:*]%%:*}}"
+    # Deal with any aliases
+    case $cmd in
+      condrestart) cmd="try-restart";;
+      force-reload) cmd="reload-or-try-restart";;
+    esac
+
+    if (( $#cmd )); then
+      curcontext="${curcontext%:*:*}:systemctl-${cmd}:"
+
+      local update_policy
+      zstyle -s ":completion:${curcontext}:" cache-policy update_policy
+      if [[ -z "$update_policy" ]]; then
+        zstyle ":completion:${curcontext}:" cache-policy _systemctl_caching_policy
+      fi
+
+      _call_function ret _systemctl_$cmd || _message 'no more arguments'
+    else
+      _message "unknown systemctl command: $words[1]"
+    fi
+    return ret
+  fi
+}
+
+__systemctl()
+{
+  local -a _modes
+  _modes=("--user" "--system")
+  systemctl ${words:*_modes} --full --no-legend --no-pager "$@"
+}
+
+
+# Fills the unit list
+_systemctl_all_units()
+{
+  if ( [[ ${+_sys_all_units} -eq 0 ]] || _cache_invalid SYS_ALL_UNITS ) &&
+    ! _retrieve_cache SYS_ALL_UNITS;
+  then
+    _sys_all_units=( $(__systemctl list-units --all | { while read a b; do echo " $a"; done; }) )
+    _store_cache SYS_ALL_UNITS _sys_all_units
+  fi
+}
+
+# Fills the unit list including all file units
+_systemctl_really_all_units()
+{
+  local -a all_unit_files;
+  local -a really_all_units;
+  if ( [[ ${+_sys_really_all_units} -eq 0 ]] || _cache_invalid SYS_REALLY_ALL_UNITS ) &&
+    ! _retrieve_cache SYS_REALLY_ALL_UNITS;
+  then
+    all_unit_files=( $(__systemctl list-unit-files | { while read a b; do echo " $a"; done; }) )
+    _systemctl_all_units
+    really_all_units=($_sys_all_units $all_unit_files)
+    _sys_really_all_units=(${(u)really_all_units})
+    _store_cache SYS_REALLY_ALL_UNITS _sys_really_all_units
+  fi
+}
+
+_filter_units_by_property() {
+  local property=$1 value=$2 ; shift ; shift
+  local -a units ; units=($*)
+  local prop unit
+  for ((i=1; $i <= ${#units[*]}; i++)); do
+    # FIXME: "Failed to issue method call: Unknown unit" errors are ignored for
+    # now (related to DBUS_ERROR_UNKNOWN_OBJECT). in the future, we need to
+    # revert to calling 'systemctl show' once for all units, which is way
+    # faster
+    unit=${units[i]}
+    prop=${(f)"$(_call_program units "$service show --no-pager --property="$property" ${unit} 2>/dev/null")"}
+    if [[ "${prop}" = "$property=$value" ]]; then
+      echo " ${unit}"
+    fi
+  done
+}
+
+_systemctl_active_units()  {_sys_active_units=(  $(__systemctl list-units          | { while read a b; do echo " $a"; done; }) )}
+_systemctl_inactive_units(){_sys_inactive_units=($(__systemctl list-units --all    | { while read a b c d; do [[ $c == "inactive" || $c == "failed" ]] && echo " $a"; done; }) )}
+_systemctl_failed_units()  {_sys_failed_units=(  $(__systemctl list-units --failed | { while read a b; do echo " $a"; done; }) )}
+_systemctl_enabled_units() {_sys_enabled_units=( $(__systemctl list-unit-files     | { while read a b; do [[ $b == "enabled" ]] && echo " $a"; done; }) )}
+_systemctl_disabled_units(){_sys_disabled_units=($(__systemctl list-unit-files     | { while read a b; do [[ $b == "disabled" ]] && echo " $a"; done; }) )}
+_systemctl_masked_units()  {_sys_masked_units=(  $(__systemctl list-unit-files     | { while read a b; do [[ $b == "masked" ]] && echo " $a"; done; }) )}
+
+# Completion functions for ALL_UNITS
+for fun in is-active is-failed is-enabled status show cat mask preset help list-dependencies ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_really_all_units
+    compadd "$@" -a - _sys_really_all_units
+  }
+done
+
+# Completion functions for ENABLED_UNITS
+for fun in disable reenable ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_enabled_units
+    _systemctl_disabled_units
+    compadd "$@" -a - _sys_enabled_units _sys_disabled_units
+  }
+done
+
+# Completion functions for DISABLED_UNITS
+(( $+functions[_systemctl_enable] )) || _systemctl_enable()
+{
+  _systemctl_disabled_units
+  compadd "$@" -a - _sys_disabled_units
+}
+
+# Completion functions for FAILED_UNITS
+(( $+functions[_systemctl_reset-failed] )) || _systemctl_reset-failed()
+{
+  _systemctl_failed_units
+  compadd "$@" -a - _sys_failed_units || _message "no failed unit found"
+}
+
+# Completion functions for STARTABLE_UNITS
+(( $+functions[_systemctl_start] )) || _systemctl_start()
+{
+  _systemctl_inactive_units
+  compadd "$@" -a - _sys_inactive_units
+}
+
+# Completion functions for STOPPABLE_UNITS
+for fun in stop kill try-restart condrestart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_active_units
+    compadd "$@" - $( _filter_units_by_property CanStop yes \
+      ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for ISOLATABLE_UNITS
+(( $+functions[_systemctl_isolate] )) || _systemctl_isolate()
+{
+  _systemctl_all_units
+  compadd "$@" - $( _filter_units_by_property AllowIsolate yes \
+    ${_sys_all_units[*]} )
+}
+
+# Completion functions for RELOADABLE_UNITS
+for fun in reload reload-or-try-restart force-reload ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_active_units
+    compadd "$@" - $( _filter_units_by_property CanReload yes \
+      ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for RESTARTABLE_UNITS
+for fun in restart reload-or-restart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_all_units
+    compadd "$@" - $( _filter_units_by_property CanStart yes \
+      ${_sys_all_units[*]} | while read line; do \
+      [[ "$line" =~ \.device$ ]] || echo " $line"; \
+      done )
+  }
+done
+
+# Completion functions for MASKED_UNITS
+(( $+functions[_systemctl_unmask] )) || _systemctl_unmask()
+{
+  _systemctl_masked_units
+  compadd "$@" -a - _sys_masked_units || _message "no masked unit found"
+}
+
+# Completion functions for JOBS
+(( $+functions[_systemctl_cancel] )) || _systemctl_cancel()
+{
+  compadd "$@" - $(__systemctl list-jobs \
+    | cut -d' ' -f1  2>/dev/null ) || _message "no job found"
+}
+
+# Completion functions for SNAPSHOTS
+(( $+functions[_systemctl_delete] )) || _systemctl_delete()
+{
+  compadd "$@" - $(__systemctl list-units --type snapshot --all \
+    | cut -d' ' -f1  2>/dev/null ) || _message "no snapshot found"
+}
+
+# Completion functions for ENVS
+for fun in set-environment unset-environment ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local fun=$0 ; fun=${fun##_systemctl_}
+    local suf
+    if [[ "${fun}" = "set-environment" ]]; then
+      suf='-S='
+    fi
+
+    compadd "$@" ${suf} - $(systemctl show-environment \
+      | while read line; do echo " ${line%%\=}";done )
+  }
+done
+
+(( $+functions[_systemctl_link] )) || _systemctl_link() { _files }
+
+# no systemctl completion for:
+#    [STANDALONE]='daemon-reexec daemon-reload default
+#                  emergency exit halt kexec list-jobs list-units
+#                  list-unit-files poweroff reboot rescue show-environment'
+#         [NAME]='snapshot'
+
+_systemctl_caching_policy()
+{
+  local _sysunits
+  local -a oldcache
+
+  # rebuild if cache is more than a day old
+  oldcache=( "$1"(mh+1) )
+  (( $#oldcache )) && return 0
+
+  _sysunits=($(__systemctl --all | cut -d' ' -f1))
+
+  if (( $#_sysunits )); then
+    for unit in $_sysunits; do
+      [[ "$unit" -nt "$1" ]] && return 0
+    done
+  fi
+
+  return 1
+}
+
+_unit_states() {
+    local -a _states
+    _states=(loaded failed active inactive not-found listening running waiting plugged mounted exited dead masked)
+    _values -s , "${_states[@]}"
+}
+
+_unit_types() {
+    local -a _types
+    _types=(automount device mount path service snapshot socket swap target timer)
+    _values -s , "${_types[@]}"
+}
+
+_unit_properties() {
+  if ( [[ ${+_sys_all_properties} -eq 0 ]] || _cache_invalid SYS_ALL_PROPERTIES ) &&
+    ! _retrieve_cache SYS_ALL_PROPERTIES;
+  then
+    _sys_all_properties=( $( {__systemctl show --all;
+       @rootlibexecdir@/systemd --dump-configuration-items; } | {
+       while IFS='=' read -r a b; do [ -n "$b" ] && echo "$a"; done
+    }) )
+    _store_cache SYS_ALL_PROPRTIES _sys_all_properties
+  fi
+  _values -s , "${_sys_all_properties[@]}"
+}
+
+_arguments -s \
+    {-h,--help}'[Show help]' \
+    '--version[Show package version]' \
+    {-t+,--type=}'[List only units of a particular type]:unit type:_unit_types' \
+    '--state=[Display units in the specifyied state]:unit state:_unit_states' \
+    {-p+,--property=}'[Show only properties by specific name]:unit property:_unit_properties' \
+    {-a,--all}'[Show all units/properties, including dead/empty ones]' \
+    '--reverse[Show reverse dependencies]' \
+    '--after[Show units ordered after]' \
+    '--before[Show units ordered before]' \
+    '--failed[Show only failed units]' \
+    {-l,--full}"[Don't ellipsize unit names on output]" \
+    '--fail[When queueing a new job, fail if conflicting jobs are pending]' \
+    '--show-types[When showing sockets, show socket type]' \
+    '--irreversible[Mark transactions as irreversible]' \
+    '--ignore-dependencies[When queueing a new job, ignore all its dependencies]' \
+    {-i,--ignore-inhibitors}'[When executing a job, ignore jobs dependencies]' \
+    {-q,--quiet}'[Suppress output]' \
+    '--no-block[Do not wait until operation finished]' \
+    '--no-legend[Do not print a legend, i.e. the column headers and the footer with hints]' \
+    '--no-pager[Do not pipe output into a pager]' \
+    '--system[Connect to system manager]' \
+    '--user[Connect to user service manager]' \
+    "--no-wall[Don't send wall message before halt/power-off/reboot]" \
+    '--global[Enable/disable unit files globally]' \
+    "--no-reload[When enabling/disabling unit files, don't reload daemon configuration]" \
+    '--no-ask-password[Do not ask for system passwords]' \
+    '--kill-who=[Who to send signal to]:killwho:(main control all)' \
+    {-s+,--signal=}'[Which signal to send]:signal:_signals' \
+    {-f,--force}'[When enabling unit files, override existing symlinks. When shutting down, execute action immediately]' \
+    '--root=[Enable unit files in the specified root directory]:directory:_directories' \
+    '--runtime[Enable unit files only temporarily until next reboot]' \
+    {-H+,--host=}'[Operate on remote host]:userathost:_sd_hosts_or_user_at_host' \
+    {-P,--privileged}'[Acquire privileges before execution]' \
+    {-n+,--lines=}'[Journal entries to show]:number of entries' \
+    {-o+,--output=}'[Change journal output mode]:modes:_sd_outputmodes' \
+    '--plain[When used with list-dependencies, print output as a list]' \
+    '*::systemctl command:_systemctl_command'
